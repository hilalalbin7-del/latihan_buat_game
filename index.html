<!doctype html>

<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Tetris Mobile — HTML/CSS/JS</title>
  <style>
    :root{
      --bg:#0f1724;--panel:#0b1220;--accent:#06b6d4;--muted:#94a3b8;--card:#071126;
      --cell-size:calc(min(9vw,48px));
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#041127 0%,#071a2a 100%);color:#e6eef6}
    .wrap{display:flex;gap:20px;align-items:flex-start;padding:20px;width:100%;max-width:1100px}
    .game{background:linear-gradient(180deg,var(--panel),#041120);padding:18px;border-radius:14px;box-shadow:0 6px 30px rgba(2,6,23,.6);display:flex;flex-direction:column;align-items:center}
    header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
    header h1{font-size:18px;margin:0}
    .board-wrap{position:relative;background:linear-gradient(180deg,#071a2a,#041124);padding:12px;border-radius:10px}
    canvas{background:linear-gradient(90deg,rgba(255,255,255,.02),transparent);border-radius:6px;display:block}
    .hud{display:flex;gap:12px;margin-top:12px;width:100%;justify-content:space-between}
    .panel{background:linear-gradient(180deg,var(--card),#041126);padding:10px;border-radius:10px;min-width:120px}
    .panel h3{margin:0 0 6px 0;font-size:12px;color:var(--muted)}
    .panel .value{font-size:20px;text-align:center}
    .controls{display:flex;flex-direction:column;gap:8px;margin-left:12px}
    .btn-row{display:flex;gap:8px}
    .btn{padding:10px 12px;border-radius:10px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);min-width:44px;text-align:center;user-select:none}
    .btn:active{transform:translateY(1px)}
    .touch-pad{position:absolute;inset:0;border-radius:6px}/* mobile overlay controls */
.mobile-controls{display:none;position:relative;margin-top:12px;width:100%;}
.mobile-row{display:flex;justify-content:space-between;align-items:center}
.big-btn{flex:1;padding:12px;border-radius:12px;margin:6px;border:1px solid rgba(255,255,255,0.04);background:linear-gradient(180deg,rgba(255,255,255,0.03),transparent)}

/* responsive */
@media (max-width:900px){
  .wrap{flex-direction:column;align-items:center}
  .controls{display:none}
  .mobile-controls{display:block}
}

/* aesthetic grid background */
.grid-bg{position:absolute;inset:12px;border-radius:6px;background-image:linear-gradient(transparent 0 calc(var(--cell-size) - 1px), rgba(255,255,255,0.02) calc(var(--cell-size) - 1px), rgba(255,255,255,0.02) calc(var(--cell-size))),linear-gradient(90deg, transparent 0 calc(var(--cell-size) - 1px), rgba(255,255,255,0.02) calc(var(--cell-size) - 1px), rgba(255,255,255,0.02) calc(var(--cell-size)));pointer-events:none}

footer{font-size:12px;color:var(--muted);margin-top:10px;text-align:center}

  </style>
</head>
<body>
  <div class="wrap">
    <div class="game" role="application" aria-label="Tetris game">
      <header>
        <div style="width:36px;height:36px;border-radius:8px;background:linear-gradient(135deg,var(--accent),#7c3aed);display:flex;align-items:center;justify-content:center;font-weight:700">T</div>
        <div>
          <h1>Tetris Mobile — HTML & JS</h1>
          <div style="font-size:12px;color:var(--muted)">Sentuhan: usap/geser/ketik — Siap dipublish ke GitHub Pages</div>
        </div>
      </header><div class="board-wrap">
    <canvas id="board"></canvas>
    <div class="grid-bg" aria-hidden="true"></div>
    <div id="touch" class="touch-pad" aria-hidden="true"></div>
  </div>

  <div class="hud">
    <div class="panel">
      <h3>Skor</h3>
      <div id="score" class="value">0</div>
    </div>
    <div class="panel">
      <h3>Baris</h3>
      <div id="lines" class="value">0</div>
    </div>
    <div class="panel">
      <h3>Level</h3>
      <div id="level" class="value">1</div>
    </div>
    <div class="controls">
      <div class="btn-row">
        <div class="btn" id="left">◀</div>
        <div class="btn" id="rotate">⟳</div>
        <div class="btn" id="right">▶</div>
      </div>
      <div class="btn-row">
        <div class="btn" id="down">▼</div>
        <div class="btn" id="drop">⇩</div>
        <div class="btn" id="pause">■</div>
      </div>
    </div>
  </div>

  <div class="mobile-controls" aria-hidden="true">
    <div class="mobile-row">
      <div class="big-btn" id="m-left">◀</div>
      <div class="big-btn" id="m-rotate">⟳</div>
      <div class="big-btn" id="m-right">▶</div>
    </div>
    <div class="mobile-row">
      <div class="big-btn" id="m-drop">⇩</div>
      <div class="big-btn" id="m-pause">■</div>
    </div>
  </div>

  <footer>Ketuk untuk putar • Geser kiri/kanan untuk geser • Geser ke bawah untuk turunkan</footer>
</div>

<aside style="width:260px;max-width:36vw">
  <div class="panel" style="margin-bottom:12px">
    <h3>Next</h3>
    <canvas id="next" width="140" height="140" style="width:100%;height:auto;border-radius:8px;background:transparent"></canvas>
  </div>
  <div class="panel">
    <h3>Panduan singkat</h3>
    <div style="font-size:13px;color:var(--muted);line-height:1.4">
      • Tap = Rotate<br>• Swipe left/right = Move<br>• Swipe down = Soft drop<br>• Hold down (button) = Hard drop<br>• Keyboard: ← → ↑ ↓ space
    </div>
  </div>
</aside>

  </div>  <script>
  // Simple Tetris implementation optimized for clarity and mobile gestures.
  (function(){
    const COLS = 10, ROWS = 20;
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('next');
    const nctx = nextCanvas.getContext('2d');
    let cell = 30;

    function resize(){
      const available = Math.min(window.innerWidth*0.55, window.innerHeight*0.8);
      cell = Math.floor(Math.min( Math.max(24, available / Math.max(COLS, ROWS)), 48));
      canvas.width = COLS * cell; canvas.height = ROWS * cell;
      canvas.style.width = canvas.width + 'px';
      canvas.style.height = canvas.height + 'px';
      document.documentElement.style.setProperty('--cell-size', cell + 'px');
      render();
    }
    window.addEventListener('resize',resize);

    // pieces & colors
    const SHAPES = {
      I: [[1,1,1,1]],
      J: [[1,0,0],[1,1,1]],
      L: [[0,0,1],[1,1,1]],
      O: [[1,1],[1,1]],
      S: [[0,1,1],[1,1,0]],
      T: [[0,1,0],[1,1,1]],
      Z: [[1,1,0],[0,1,1]]
    };
    const COLORS = {I:'#06b6d4',J:'#7c3aed',L:'#fb923c',O:'#facc15',S:'#34d399',T:'#ef476f',Z:'#60a5fa'};
    function randPiece(){ const keys = Object.keys(SHAPES); const k = keys[Math.floor(Math.random()*keys.length)]; return {shape:SHAPES[k].map(r=>r.slice()),type:k,color:COLORS[k]}; }

    // board
    const board = Array.from({length:ROWS},()=>Array(COLS).fill(null));
    let current = null, next = randPiece();
    let score=0, lines=0, level=1;
    let dropInterval = 800; let lastTime=0; let paused=false;

    function spawn(){ current = next; next = randPiece(); current.x = Math.floor((COLS - current.shape[0].length)/2); current.y = 0; if(collides(current,0,0)){ gameOver(); }
    }

    function rotateShape(shape){ const H = shape.length, W = shape[0].length; const out = Array.from({length:W},()=>Array(H).fill(0)); for(let r=0;r<H;r++) for(let c=0;c<W;c++) out[c][H-1-r]=shape[r][c]; return out; }
    function collides(piece,dx,dy,rot){ let shape = rot?rotateShape(piece.shape):piece.shape; for(let r=0;r<shape.length;r++) for(let c=0;c<shape[0].length;c++) if(shape[r][c]){
      const x = piece.x + c + dx; const y = piece.y + r + dy; if(x<0||x>=COLS||y>=ROWS) return true; if(y>=0 && board[y][x]) return true; }
      return false; }

    function fixPiece(){ const shape = current.shape; for(let r=0;r<shape.length;r++) for(let c=0;c<shape[0].length;c++) if(shape[r][c]){
      const x=current.x+c, y=current.y+r; if(y>=0) board[y][x] = {color:current.color}; }
      clearLines(); spawn(); }

    function clearLines(){ let cleared=0; outer: for(let r=ROWS-1;r>=0;r--){ for(let c=0;c<COLS;c++) if(!board[r][c]) continue outer; // full
        board.splice(r,1); board.unshift(Array(COLS).fill(null)); cleared++; r++; }
      if(cleared){ lines+=cleared; score += [0,100,250,400,650][cleared] || cleared*200; level = Math.floor(lines/10)+1; dropInterval = Math.max(80, 800 - (level-1)*60); updateHud(); }
    }

    function updateHud(){ document.getElementById('score').textContent = score; document.getElementById('lines').textContent = lines; document.getElementById('level').textContent = level; }

    function gameOver(){ paused=true; alert('Game Over — Skor: '+score); reset(); }
    function reset(){ for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) board[r][c]=null; score=0; lines=0; level=1; dropInterval=800; paused=false; next=randPiece(); spawn(); updateHud(); }

    function hardDrop(){ while(!collides(current,0,1)) current.y++; fixPiece(); }

    function move(dx){ if(!collides(current,dx,0)) current.x+=dx; }
    function softDrop(){ if(!collides(current,0,1)) current.y++; else fixPiece(); }
    function rotate(){ const rotated = rotateShape(current.shape); if(!collides({...current,shape:rotated},0,0)){ current.shape = rotated; } }

    // render
    function drawCell(x,y,color,alpha){ ctx.globalAlpha = alpha||1; ctx.fillStyle = color; ctx.fillRect(x*cell+1,y*cell+1,cell-2,cell-2); ctx.globalAlpha = 1; ctx.strokeStyle = 'rgba(0,0,0,0.18)'; ctx.strokeRect(x*cell+1,y*cell+1,cell-2,cell-2);
    }
    function render(){ ctx.clearRect(0,0,canvas.width,canvas.height);
      // board background
      ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      // fixed
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(board[r][c]) drawCell(c,r,board[r][c].color);
      // current
      if(current){ const s = current.shape; for(let r=0;r<s.length;r++) for(let c=0;c<s[0].length;c++) if(s[r][c]){
        const x=current.x+c, y=current.y+r; if(y>=0) drawCell(x,y,current.color);
      }}
      // grid lines subtle
      ctx.strokeStyle='rgba(255,255,255,0.02)'; for(let x=0;x<=COLS;x++){ ctx.beginPath(); ctx.moveTo(x*cell,0); ctx.lineTo(x*cell,ROWS*cell); ctx.stroke(); }
      for(let y=0;y<=ROWS;y++){ ctx.beginPath(); ctx.moveTo(0,y*cell); ctx.lineTo(COLS*cell,y*cell); ctx.stroke(); }
      renderNext();
    }

    function renderNext(){ nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height); nctx.save(); nctx.translate(nextCanvas.width/2, nextCanvas.height/2); nctx.scale(1,1);
      const s = next.shape; const w = s[0].length, h = s.length; const size = Math.min(28, Math.floor(Math.min(nextCanvas.width/(w+1), nextCanvas.height/(h+1))));
      for(let r=0;r<h;r++) for(let c=0;c<w;c++) if(s[r][c]){
        nctx.fillStyle = next.color; nctx.fillRect((c - w/2 + 0.5)*size + nextCanvas.width/2 - size/2, (r - h/2 + 0.5)*size + nextCanvas.height/2 - size/2, size-2, size-2);
      }
      nctx.restore();
    }

    // game loop
    function loop(ts){ if(!lastTime) lastTime = ts; const delta = ts - lastTime; if(!paused){ if(delta > dropInterval){ softDrop(); lastTime = ts; render(); }} requestAnimationFrame(loop); }

    // keyboard & buttons
    document.getElementById('left').addEventListener('click',()=>{ move(-1); render(); });
    document.getElementById('right').addEventListener('click',()=>{ move(1); render(); });
    document.getElementById('rotate').addEventListener('click',()=>{ rotate(); render(); });
    document.getElementById('down').addEventListener('mousedown',()=>{ softDrop(); render(); });
    document.getElementById('drop').addEventListener('click',()=>{ hardDrop(); render(); });
    document.getElementById('pause').addEventListener('click',()=>{ paused = !paused; });

    // mobile buttons
    ['m-left','m-right','m-rotate','m-drop','m-pause'].forEach(id=>{ const el=document.getElementById(id); if(!el) return; el.addEventListener('click',()=>{
      if(id==='m-left'){ move(-1);} else if(id==='m-right'){ move(1);} else if(id==='m-rotate'){ rotate(); } else if(id==='m-drop'){ hardDrop(); } else if(id==='m-pause'){ paused=!paused; }
      render();
    }); });

    // keyboard
    window.addEventListener('keydown', (e)=>{
      if(e.key==='ArrowLeft') move(-1);
      else if(e.key==='ArrowRight') move(1);
      else if(e.key==='ArrowDown') softDrop();
      else if(e.key===' ') hardDrop();
      else if(e.key==='ArrowUp') rotate();
      render();
    });

    // touch gestures
    (function touchControl(){
      const pad = document.getElementById('touch');
      let sx=0, sy=0, moved=false, startTime=0;
      pad.addEventListener('touchstart', (ev)=>{
        const t = ev.touches[0]; sx = t.clientX; sy = t.clientY; moved=false; startTime = Date.now();
      },{passive:true});
      pad.addEventListener('touchmove', (ev)=>{ moved=true; },{passive:true});
      pad.addEventListener('touchend', (ev)=>{
        const t = ev.changedTouches[0]; const ex = t.clientX, ey = t.clientY; const dx = ex - sx, dy = ey - sy;
        const distX = Math.abs(dx), distY = Math.abs(dy);
        const time = Date.now() - startTime;
        // tap
        if(!moved || (distX<10 && distY<10 && time<250)){
          rotate(); render(); return;
        }
        // horizontal swipe
        if(distX > distY && distX > 25){ if(dx>0) move(1); else move(-1); render(); return; }
        // vertical swipe
        if(distY > distX && distY > 25){ if(dy>0) softDrop(); else {/* swipe up can be rotate */ rotate();*/} render(); return; }
      },{passive:true});

      // long press for hard drop
      let longTimer=null;
      pad.addEventListener('touchstart', (e)=>{ longTimer = setTimeout(()=>{ hardDrop(); render(); }, 600); },{passive:true});
      pad.addEventListener('touchend', ()=>{ if(longTimer) clearTimeout(longTimer); });
    })();

    // init
    resize(); updateHud(); spawn(); render(); requestAnimationFrame(loop);
  })();
  </script></body>
</html>
